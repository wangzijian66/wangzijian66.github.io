<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="John Doe"><meta name="renderer" content="webkit"><meta name="copyright" content="John Doe"><meta name="keywords" content="My"><meta name="description" content=""><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>嘉年华幸运转盘 · Shiter's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/p2.png"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/p1.png"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">wangzijian</div><div class="profile-signature">Go with the flow</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Shiter's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">嘉年华幸运转盘</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2025-07-25</span></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><p>这是一个使用 Three.js 制作的交互式3D幸运转盘。点击 “enter” 后，可以通过拖动拉杆来旋转转盘！</p>
<span id="more"></span>
<!-- START: 嘉年华旋转器嵌入式代码 -->
<div id="carnival-spinner-wrapper">
  <div id="container">
    <div id="lottie"></div>
    <div id="enter-button-container">
      <button id="enter-btn">enter</button>
    </div>
  </div>
  <canvas class="webgl"></canvas>
</div>

<style>
  /* 将所有样式限制在 #carnival-spinner-wrapper 内部，防止影响博客主题 */
  #carnival-spinner-wrapper {
    position: relative; /* 关键：为内部绝对定位的元素提供一个容器 */
    width: 100%;
    height: 70vh; /* 您可以调整这个高度 */
    min-height: 500px;
    margin: 20px 0;
    overflow: hidden; /* 关键：只在这个容器内部隐藏溢出 */
    font-family: Aleo, sans-serif;
    font-weight: 400;
  }

  #carnival-spinner-wrapper .webgl {
    position: absolute; /* 从 fixed 改为 absolute */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    outline: none;
  }

  #carnival-spinner-wrapper #container {
    background-image: url(https://assets.codepen.io/262181/intro-bg.jpg);
    background-size: cover;
    background-position: center;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 101;
    position: absolute;
    top: 0;
    left: 0;
    color: #9d988a;
    font-size: 0.9em;
  }

  #carnival-spinner-wrapper #lottie {
    height: 40vh;
    max-height: 400px;
    z-index: 102;
    display: flex;
  }

  #carnival-spinner-wrapper #enter-button-container {
    width: auto;
  }

  #carnival-spinner-wrapper button {
    cursor: pointer;
    margin-top: 4px;
    padding: 8px 16px; /* 增大按钮，方便点击 */
    background-color: #9d988a;
    color: #6b2414;
    border-radius: 4px;
    border: none;
    font-size: 1.1em;
  }
</style>

<!-- 关键：添加 type="module" -->
<script type="module">
  import * as THREE from "https://esm.sh/three@0.174.0";
  import { OrbitControls } from "https://esm.sh/three@0.174.0/addons/controls/OrbitControls.js";
  import { GLTFLoader } from "https://esm.sh/three@0.174.0/examples/jsm/loaders/GLTFLoader.js";
  import { DRACOLoader } from "https://esm.sh/three@0.174.0/examples/jsm/loaders/DRACOLoader";
  import Lottie from "https://esm.sh/lottie-web";

  // 获取容器元素
  const wrapper = document.getElementById('carnival-spinner-wrapper');
  const container = wrapper.querySelector("#container");
  const enterButton = wrapper.querySelector("#enter-btn");
  const lottieContainer = wrapper.querySelector("#lottie");
  const canvas = wrapper.querySelector("canvas.webgl");

  let start3 = false;
  let anim = null;
  let camera, scene, renderer, controls, clock;
  let wheel, lever = null, hitArea = null, pullSign = null;
  let ready = false;
  let speed = 0;
  let inc = 0.02;
  let mouse = { direction: null, pressing: false, curY: null, isClicking: false, dragStarted: false, dragDistance: 0, isSpinning: false };
  let revealAnim = { isAnimating: false, isShowing: false };
  let signSpinSpeed = 1;
  let incSpeed = 12;
  let resultSign = null, resultAnim = null, animAction = null, animMixer = null;
  let numArr = [];
  let deviceType = null;
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();
  
  let cameraSetup = {
    cameraIsSettled: false,
    cameraTgt: { x: 0.11611507465368477, y: 3.5939784540499456e-16, z: 5.8682635668005005 },
    totalIterations: 900,
    iteration: 0,
    leverTgt: 1
  };

  const start = () => {
    container.style.display = "none";
    start3 = true;
    if (anim) anim.stop();
  };

  enterButton.addEventListener('click', start);

  const initLottie = () => {
    anim = Lottie.loadAnimation({
      container: lottieContainer,
      renderer: "svg",
      loop: true,
      autoplay: true,
      path: "https://assets.codepen.io/262181/crnvlintro.json"
    });
    const loop = () => anim.goToAndPlay(120, true);
    anim.addEventListener("loopComplete", loop);
  };

  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
  deviceType = isMobile ? "mobile" : "desktop";

  const getTarget = (e) => (deviceType == "mobile" ? e.targetTouches[0] : e);

  const isDown = (e) => {
    const tgt = getTarget(e);
    if (!tgt) return;

    mouse.pressing = true;
    mouse.x = tgt.clientX;
    mouse.y = tgt.clientY;

    const rect = canvas.getBoundingClientRect();
    pointer.x = ((tgt.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -((tgt.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(pointer, camera);

    const intersects = raycaster.intersectObject(hitArea);
    if (intersects.length > 0) {
      e.preventDefault();
      controls.enableRotate = false;
      mouse.isClicking = true;
    }
  };

  const isUp = (e) => {
    mouse.pressing = false;
    mouse.isClicking = false;
    mouse.direction = null;
    controls.enableRotate = true;
    if (mouse.dragStarted) {
      mouse.dragStarted = false;
      lever.rotation.x = 1;
    }
  };

  const isMove = (e) => {
    const tgt = getTarget(e);
    if (!tgt) return;
    
    if (mouse.pressing && mouse.isClicking) {
      e.preventDefault();
      controls.enableRotate = false;

      if (mouse.curY != null && mouse.curY < tgt.clientY) {
        if (mouse.direction != "down") {
          mouse.direction = "down";
          mouse.dragDistance = 0;
        } else {
          let dist = tgt.clientY - mouse.curY;
          mouse.dragStarted = true;
          mouse.dragDistance += dist;
          let r = Math.min(2, mouse.dragDistance / 100 + 1);
          lever.rotation.x = r;
          if (inc < 0.4) inc += r / 100;
        }
      } else if (mouse.curY != null && mouse.curY > tgt.clientY) {
        mouse.direction = "up";
      }
      mouse.curY = tgt.clientY;
    } else {
      mouse.direction = null;
      mouse.curY = null;
    }
  };

  function init() {
    wrapper.addEventListener("touchstart", isDown, { passive: false });
    wrapper.addEventListener("mousedown", isDown);
    window.addEventListener("mouseup", isUp); // a mouseup can happen anywhere
    window.addEventListener("touchend", isUp);
    wrapper.addEventListener("mousemove", isMove, { passive: false });
    wrapper.addEventListener("touchmove", isMove, { passive: false });
    
    initLottie();
    
    scene = new THREE.Scene();
    clock = new THREE.Clock();
    
    const sizes = { width: wrapper.clientWidth, height: wrapper.clientHeight };

    camera = new THREE.PerspectiveCamera(35, sizes.width / sizes.height, 0.1, 100);
    camera.position.set(10, -2.3, -15.4);
    scene.add(camera);

    controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.minDistance = 4;
    controls.maxDistance = 7;
    controls.maxPolarAngle = Math.PI / 2;
    controls.maxAzimuthAngle = 0.785;
    controls.minAzimuthAngle = -1.5;

    renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(sizes.width, sizes.height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    
    const textureLoader = new THREE.TextureLoader();
    const bakedTexture = textureLoader.load("https://assets.codepen.io/262181/baked.jpg");
    bakedTexture.flipY = false;
    bakedTexture.colorSpace = THREE.SRGBColorSpace;
    const wheelTexture = textureLoader.load("https://assets.codepen.io/262181/wheel.jpg");
    wheelTexture.flipY = false;
    wheelTexture.colorSpace = THREE.SRGBColorSpace;
    const shadowTexture = textureLoader.load("https://assets.codepen.io/262181/shadow.png");
    shadowTexture.flipY = false;
    shadowTexture.colorSpace = THREE.SRGBColorSpace;

    const bakedMaterial = new THREE.MeshBasicMaterial({ map: bakedTexture });
    const wheelMaterial = new THREE.MeshBasicMaterial({ map: wheelTexture });
    const shadowMaterial = new THREE.MeshBasicMaterial({ map: shadowTexture, transparent: true, opacity: 0.5 });
    const transpMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0 });

    // 关键：修正 Draco 解码器路径为CDN绝对路径
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/");

    const gltfLoader = new GLTFLoader();
    gltfLoader.setDRACOLoader(dracoLoader);
    gltfLoader.load("https://assets.codepen.io/262181/carnival.glb", (gltf) => {
      gltf.scene.traverse((child) => {
        if (child.name == "lever") { lever = child; lever.rotation.x = 2; child.material = bakedMaterial; }
        else if (child.name == "hitarea") { hitArea = child; child.material = transpMaterial; }
        else if (child.name == "wheel") { wheel = child; child.material = wheelMaterial; ready = true; }
        else if (child.name == "shadow") { child.material = shadowMaterial; }
        else if (child.name == "sign_swing") { pullSign = child; child.material = bakedMaterial; }
        else if (child.name == "result_panel") { child.material = bakedMaterial; initResultAnimation(child, gltf); }
        else if (child.name.includes("num")) { numArr.push(child); child.material = bakedMaterial; child.visible = false; }
        else { child.material = bakedMaterial; }
      });
      scene.add(gltf.scene);
    });

    const onResize = () => {
      sizes.width = wrapper.clientWidth;
      sizes.height = wrapper.clientHeight;
      camera.aspect = sizes.width / sizes.height;
      camera.updateProjectionMatrix();
      renderer.setSize(sizes.width, sizes.height);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    };
    new ResizeObserver(onResize).observe(wrapper);
  }

  let initResultAnimation = (child, gltf) => {
    resultSign = child;
    resultAnim = THREE.AnimationClip.findByName(gltf.animations, "result_panelAction");
    animMixer = new THREE.AnimationMixer(resultSign);
    animMixer.addEventListener("finished", (e) => manageRevealAnim(e));
    animAction = animMixer.clipAction(resultAnim);
    animAction.reset();
    animAction.clampWhenFinished = true;
    animAction.timeScale = 1;
    animAction.setLoop(THREE.LoopOnce, 1);
  };

  let manageRevealAnim = (e) => {
    if (revealAnim.isShowing) { if (!mouse.isSpinning) revealAnim.isShowing = false; }
    else { if (!mouse.isSpinning) revealAnim.isShowing = true; }
    revealAnim.isAnimating = false;
    animAction.paused = true;
  };

  let showNumber = (answer) => {
    numArr.forEach(n => n.visible = false);
    if(numArr[answer - 1]) numArr[answer - 1].visible = true;
  };

  let easeOutCubic = (t, b, c, d) => (t /= d, t--, c * (t * t * t + 1) + b);
  let easeInOutCubic = (t, b, c, d) => ((t /= d / 2) < 1 ? c / 2 * t * t * t + b : (t -= 2, c / 2 * (t * t * t + 2) + b));

  const tick = () => {
    requestAnimationFrame(tick);
    if (!ready || !renderer) return;

    controls.update();

    if (start3) {
      if (!cameraSetup.cameraIsSettled) {
        cameraSetup.iteration++;
        if (cameraSetup.iteration < 100) {
          let xx = easeOutCubic(cameraSetup.iteration, camera.position.x, cameraSetup.cameraTgt.x - camera.position.x, cameraSetup.totalIterations);
          let yy = easeOutCubic(cameraSetup.iteration, camera.position.y, cameraSetup.cameraTgt.y - camera.position.y, cameraSetup.totalIterations);
          let zz = easeOutCubic(cameraSetup.iteration, camera.position.z, cameraSetup.cameraTgt.z - camera.position.z, cameraSetup.totalIterations);
          camera.position.set(xx, yy, zz);
          lever.rotation.x = easeInOutCubic(cameraSetup.iteration, lever.rotation.x, cameraSetup.leverTgt - lever.rotation.x, 80);
        } else {
          cameraSetup.cameraIsSettled = true;
        }
      }

      speed += inc;
      if (inc > 0) {
        if (!mouse.isSpinning) inc += 0.1;
        wheel.rotation.z = speed;
        inc -= 0.001;
        mouse.isSpinning = true;
        if (revealAnim.isShowing) {
          animAction.paused = false;
          revealAnim.isAnimating = true;
          animAction.setLoop(THREE.LoopOnce);
          animAction.timeScale = -1;
          animAction.time = 0.5;
          animAction.play();
          revealAnim.isShowing = false;
        }
      } else {
        if (mouse.isSpinning) {
          let rad = (wheel.rotation.z * (180 / Math.PI)) % 360;
          let answer = Math.floor(1 + rad / 36);
          showNumber(answer);
          mouse.isSpinning = false;
          animAction.paused = false;
          revealAnim.isAnimating = true;
          animAction.setLoop(THREE.LoopOnce);
          animAction.timeScale = 1;
          animAction.play();
        }
      }
      
      if (incSpeed > 0 && pullSign != null) {
        pullSign.rotation.z = Math.sin(signSpinSpeed) / 3;
        signSpinSpeed += incSpeed / 100;
        incSpeed -= 0.068;
      }
    }
    
    if (animMixer) animMixer.update(clock.getDelta());
    renderer.render(scene, camera);
  };
  
  // 启动
  init();
  tick();

</script>
<!-- END: 嘉年华旋转器嵌入式代码 --></article><!-- lincense--><div class="post-paginator"><a class="nextSlogan" href="/2025/07/22/md%E5%AD%A6%E4%B9%A0/" title="markdown学习"><span>NextPost ></span><br><span class="nextTitle">markdown学习</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a target="_blank" rel="noopener" href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>