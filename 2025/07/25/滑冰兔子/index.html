<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="John Doe"><meta name="renderer" content="webkit"><meta name="copyright" content="John Doe"><meta name="keywords" content="My"><meta name="description" content=""><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>滑冰兔子 · Shiter's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/p2.png"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/p1.png"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">wangzijian</div><div class="profile-signature">Go with the flow</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Shiter's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">滑冰兔子</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2025-07-25</span></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><p>这是一个非常酷炫和技术含量很高的 3D 交互式场景，主角是一只可爱的兔子。它不仅仅是一个简单的游戏，更像是一个高级渲染技术和物理模拟的展示。</p>
<span id="more"></span>

<!-- START: 弹性兔子游戏嵌入式代码 -->
<div id="rabbit-game-wrapper">
  <canvas class="webgl"></canvas>

  <div class="instructions"> - Press to jump - </div>

  <div class="credits">
    <p><a href="https://codepen.io/Yakudoo/" target="blank">my other codepens</a> | <a href="http://epic.net" target="blank">epic.net</a></p>
  </div>

  <!-- 着色器代码 -->
  <script type="x-shader/x-vertex" class="reflectorVertexShader">
    uniform mat4 textureMatrix;
    varying vec4 vUvReflection;
    varying vec2 vUv; 
    #include <common>
    #include <shadowmap_pars_vertex>
    #include <logdepthbuf_pars_vertex>
    void main() {
        #include <beginnormal_vertex>
        #include <defaultnormal_vertex>
        #include <begin_vertex>
        vUvReflection = textureMatrix * vec4( position, 1.0 );
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        #include <logdepthbuf_vertex>
        #include <worldpos_vertex>
        #include <shadowmap_vertex>
    }
  </script> 
  <script type="x-shader/x-fragment" class="reflectorFragmentShader">
    uniform vec3 color;
    uniform sampler2D tDiffuse;
    uniform sampler2D tScratches;
    varying vec4 vUvReflection;
    varying vec2 vUv;
    #include <common>
    #include <packing>
    #include <lights_pars_begin>
    #include <shadowmap_pars_fragment>
    #include <shadowmask_pars_fragment>
    #include <logdepthbuf_pars_fragment>
    vec4 blur9(sampler2D image, vec4 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3846153846) * direction;
        vec2 off2 = vec2(3.2307692308) * direction;
        color += texture2DProj(image, uv) * 0.2270270270;
        color += texture2DProj(image, uv + vec4(off1 / resolution, off1 / resolution)) * 0.3162162162;
        color += texture2DProj(image, uv - vec4(off1 / resolution, off1 / resolution)) * 0.3162162162;
        color += texture2DProj(image, uv + vec4(off2 / resolution, off2 / resolution)) * 0.0702702703;
        color += texture2DProj(image, uv - vec4(off2 / resolution, off2 / resolution)) * 0.0702702703;
        return color;
    }
    float blendOverlay( float base, float blend ) { return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) ); }
    vec3 blendOverlay( vec3 base, vec3 blend ) { return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) ); }
    void main() {
        #include <logdepthbuf_fragment>
        vec4 displacement = vec4( sin(vUvReflection.y * 3.) * .05, sin(vUvReflection.x * 3.) * .05, 0.0, 0.0);
        vec2 resolution = vec2(30., 30.);
        vec4 base = blur9( tDiffuse, vUvReflection + displacement, resolution, vec2(1., 0.) ) * .25;
        base += blur9( tDiffuse, vUvReflection + displacement, resolution, vec2(-1., 0.) ) * .25;
        base += blur9( tDiffuse, vUvReflection + displacement, resolution, vec2(0, 1.) ) * .25;
        base += blur9( tDiffuse, vUvReflection + displacement, resolution, vec2(0, -1.) ) * .25;
        vec4 scratchesCol = texture2D( tScratches, vUv);
        vec3 col = mix(color, base.rgb, .5);
        col.rgb += scratchesCol.r * .02;
        col.gb -= scratchesCol.g * .01;
        col.gb -= (1.0 - getShadowMask() ) * .015;
        gl_FragColor = vec4(col, 1.0);
        #include <tonemapping_fragment>
        #include <colorspace_fragment>
    }
  </script>  
  <script type="x-shader/x-vertex" class="simulationVertexShader">
    precision highp float;
    uniform float time;
    varying vec2 vUv;
    void main() {
      vUv = uv;
      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      gl_Position = projectionMatrix * modelViewPosition; 
    }
  </script>
  <script type="x-shader/x-fragment" class="simulationFragmentShader">
    precision highp float;
    uniform sampler2D inputTexture;
    uniform vec2 blade1PosOld;
    uniform vec2 blade1PosNew;
    uniform float strength;
    uniform float time;
    varying vec2 vUv;
    float lineSegment(vec2 p, vec2 a, vec2 b, float thickness) {
        vec2 pa = p - a;
        vec2 ba = b - a;
        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
        float idk = length(pa - ba*h);
        return smoothstep(thickness, .2 * thickness, idk);
    }
    void main(void) {
      vec4 prevTexture = texture2D(inputTexture, vUv);
      vec3 col = prevTexture.rgb * .999;
      if (strength>0.){
          float space = .001;
          float crease = .001;
          float thickness = .001 + strength * .001;
          float leftRed = lineSegment(vUv + space, blade1PosOld, blade1PosNew, thickness);
          float leftGreen = lineSegment(vUv + space + crease, blade1PosOld, blade1PosNew, thickness);
          float rightRed = lineSegment(vUv - space - crease, blade1PosOld, blade1PosNew, thickness);
          float rightGreen = lineSegment(vUv - space, blade1PosOld, blade1PosNew, thickness);
          col.r += ( leftRed + rightRed ) * strength * 3.0;
          col.g += ( leftGreen + rightGreen) * strength * 3.0;
          col.r = clamp(col.r, .0, 1.0);
          col.g = clamp(col.g, .0, 1.0);
      }
      gl_FragColor = vec4(col, 1.0);
    }
  </script>
  <script type="x-shader/x-fragment" class="outlineFragmentShader">
    uniform vec3 color;
    void main(void) { gl_FragColor = vec4( color, 1.0); }
  </script>
  <script type="x-shader/x-vertex" class="outlineVertexShader">
    uniform float size;
    uniform float time;
    void main() {
      vec3 transformed = position + normal * size * (1.0 + abs( sin ( position.y * time * .02 ) * 2.0 ));
      vec4 modelViewPosition = modelViewMatrix * vec4(transformed, 1.0);
      gl_Position = projectionMatrix * modelViewPosition; 
    }
  </script>
</div>

<style>
  @import url(https://fonts.googleapis.com/css?family=Open+Sans:600);

  #rabbit-game-wrapper {
    position: relative; /* 关键：为内部绝对定位的元素提供容器 */
    width: 100%;
    height: 80vh; /* 您可以调整此高度 */
    min-height: 600px;
    margin: 20px 0;
    overflow: hidden; /* 仅在此容器内隐藏溢出 */
  }

  #rabbit-game-wrapper .webgl {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    outline: none;
    background-color: #000000;
    cursor: move;
    cursor: grabbing;
    cursor: -moz-grabbing;
    cursor: -webkit-grabbing;
  }

  #rabbit-game-wrapper .credits,
  #rabbit-game-wrapper .instructions {
    position: absolute;
    width: 100%;
    left: 0;
    margin: auto;
    font-family: "Open Sans", sans-serif;
    color: #544027;
    font-size: 0.7em;
    text-transform: uppercase;
    text-align: center;
    z-index: 10;
  }
  
  #rabbit-game-wrapper .credits {
    bottom: 20px;
  }
  
  #rabbit-game-wrapper .instructions {
    bottom: 60px;
    color: #ff3434;
  }

  #rabbit-game-wrapper .credits a {
    color: #7beeff;
  }

  #rabbit-game-wrapper .credits a:hover {
    color: #ff3434;
  }
</style>

<script type="module">
  import * as THREE from "https://esm.sh/three@0.156.1";
  import { OrbitControls } from "https://esm.sh/three@0.156.1/examples/jsm/controls/OrbitControls.js";
  import { GLTFLoader } from "https://esm.sh/three@0.156.1/examples/jsm/loaders/GLTFLoader";
  import gsap from "https://esm.sh/gsap";
  import { Reflector } from "https://esm.sh/three@0.156.1/examples/jsm/objects/Reflector";

  const gameWrapper = document.getElementById('rabbit-game-wrapper');

  if (gameWrapper) {
    // ---- BufferSim Class Definition ----
    class BufferSim {
        constructor ( renderer, width, height, shader ) {
            this.renderer = renderer;
            this.shader = shader;
            this.orthoScene = new THREE.Scene();
            var fbo = new THREE.WebGLRenderTarget( width, height, {
                wrapS: THREE.ClampToEdgeWrapping,
                wrapT: THREE.ClampToEdgeWrapping,
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                type: THREE.FloatType,
                stencilBuffer: false,
                depthBuffer: false
            });
            fbo.texture.generateMipmaps = false;
            this.fbos = [ fbo, fbo.clone() ];
            this.current = 0;
            this.output = this.fbos[ 0 ];
            this.orthoCamera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, .00001, 1000 );
            this.orthoQuad = new THREE.Mesh( new THREE.PlaneGeometry( width, height ), this.shader );
            this.orthoScene.add( this.orthoQuad );
        }
        render(){
            this.shader.uniforms.inputTexture.value = this.fbos[ this.current ].texture;
            this.input = this.fbos[ this.current ];
            this.current = 1 - this.current;
            this.output = this.fbos[ this.current ];
            this.renderer.setRenderTarget(this.output);
            this.renderer.render( this.orthoScene, this.orthoCamera );
            this.renderer.setRenderTarget(null);
        }
    }

    // ---- App Class Definition ----
    class App {
      constructor() {
        this.winWidth = gameWrapper.clientWidth;
        this.winHeight = gameWrapper.clientHeight;
        this.gltfFile = "https://assets.codepen.io/264161/rabbit6.glb";
        this.loadAssets();
      }

      loadAssets() {
        const loaderModel = new GLTFLoader();
        loaderModel.load(this.gltfFile, (gltf) => {
          this.model = gltf.scene;
          this.setUpScene();
        });
      }

      setUpScene() {
        this.scene = new THREE.Scene();
        this.bgrColor = 0x332e2e;
        this.fog = new THREE.Fog(this.bgrColor, 13, 20);
        this.scene.fog = this.fog;
        this.camera = new THREE.PerspectiveCamera(60, this.winWidth / this.winHeight, 1, 100);
        this.camera.position.set(0, 4, 8);
        this.camera.lookAt(new THREE.Vector3());
        this.scene.add(this.camera);

        this.heroAngularSpeed = 0; this.heroOldRot = 0; this.heroDistance = 0;
        this.heroOldUVPos = new THREE.Vector2(0.5, 0.5); this.heroNewUVPos = new THREE.Vector2(0.5, 0.5);
        this.heroSpeed = new THREE.Vector2(0, 0); this.heroAcc = new THREE.Vector2(0, 0);
        this.targetHeroUVPos = new THREE.Vector2(0.5, 0.5); this.targetHeroAbsMousePos = new THREE.Vector2(0, 0);
        this.raycaster = new THREE.Raycaster(); this.mouse = new THREE.Vector2();
        this.isJumping = this.isLanding = false; this.jumpParams = { jumpProgress: 0, landProgress: 0 };
        this.clock = new THREE.Clock(); this.time = 0; this.deltaTime = 0;
        
        this.createRenderer();
        this.createSim();
        this.createListeners();

        this.floorSize = 30;
        this.createMaterials();
        this.processModel();
        this.createFloor();
        this.createLine();
        this.createLight();
        this.createParticles();

        this.draw();
      }

      processModel() {
        this.rabbit = this.model.getObjectByName("Rabbit");
        this.rabbitBody = this.model.getObjectByName("body");
        this.earRight = this.model.getObjectByName("earRight");
        this.earLeft = this.model.getObjectByName("earLeft");
        this.tail = this.model.getObjectByName("tail");
        this.footLeft = this.model.getObjectByName("footLeft");
        this.footRight = this.model.getObjectByName("footRight");
        this.eyeLeft = this.model.getObjectByName("eyeLeft");
        this.eyeRight = this.model.getObjectByName("eyeRight");
        this.carrot = this.model.getObjectByName("carrot");
        this.carrotLeaf = this.model.getObjectByName("carrotLeaf");
        this.carrotLeaf2 = this.model.getObjectByName("carrotLeaf2");

        this.carrot.rotation.z = 0.2; this.carrot.rotation.x = 0.2;
        this.rabbitBody.material = this.primMat; this.earRight.material = this.primMat;
        this.earLeft.material = this.primMat; this.tail.material = this.primMat;
        this.footLeft.material = this.secMat; this.footRight.material = this.secMat;
        this.eyeLeft.material = this.secMat; this.eyeRight.material = this.secMat;
        this.carrot.material = this.bonusMat; this.carrotLeaf.material = this.primMat;
        this.carrotLeaf2.material = this.primMat;
        
        this.addOutline(this.rabbitBody); this.addOutline(this.earRight);
        this.addOutline(this.earLeft); this.addOutline(this.tail);
        this.addOutline(this.carrot);

        this.rabbit.traverse((object) => { if (object.isMesh) { object.castShadow = true; object.receiveShadow = true; }});
        this.carrot.traverse((object) => { if (object.isMesh) object.castShadow = true; });

        this.scene.add(this.rabbit);
        this.scene.add(this.carrot);
      }

      createFloor() {
        this.floor = new Reflector(new THREE.PlaneGeometry(this.floorSize, this.floorSize), { color: new THREE.Color(this.bgrColor), textureWidth: 1024, textureHeight: 1024 });
        this.floor.rotation.x = -Math.PI / 2;
        this.floor.receiveShadow = true;
        this.modifyFloorShader();
        this.scene.add(this.floor);
      }

      createLine() {
        const material = new THREE.LineDashedMaterial({ color: 0x7beeff, linewidth: 1, scale: 1, dashSize: 0.2, gapSize: 0.1 });
        const points = [new THREE.Vector3(0, 0.2, 0), new THREE.Vector3(3, 0.2, 3)];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        this.line = new THREE.Line(geometry, material);
        this.scene.add(this.line);
      }
      
      createParticles(){
        let particleGeom = new THREE.BoxGeometry(.2,.2,.2,1,1,1);
        this.particles1 = Array.from({ length: 20 }, () => {
            let m = new THREE.Mesh(particleGeom, this.bonusMat);
            m.scale.set(0,0,0); this.scene.add(m); return m;
        });
        this.particles2 = Array.from({ length: 5 }, () => {
            let m = new THREE.Mesh(particleGeom, this.primMat);
            m.scale.set(0,0,0); this.scene.add(m); return m;
        });
      }

      createLight() {
        this.ambientLight = new THREE.AmbientLight(0xffffff);
        this.scene.add(this.ambientLight);
        this.light = new THREE.DirectionalLight(0xffffff, 1);
        this.light.position.set(1, 5, 1);
        this.light.castShadow = true;
        this.light.shadow.mapSize.width = 512; this.light.shadow.mapSize.height = 512;
        this.light.shadow.camera.near = 0.5; this.light.shadow.camera.far = 12;
        this.light.shadow.camera.left = -12; this.light.shadow.camera.right = 12;
        this.light.shadow.camera.bottom = -12; this.light.shadow.camera.top = 12;
        this.light.shadow.radius = 3; this.light.shadow.blurSamples = 4;
        this.scene.add(this.light);
      }

      createRenderer() {
        const canvas = gameWrapper.querySelector("canvas.webgl");
        this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true });
        this.renderer.setClearColor(new THREE.Color(this.bgrColor));
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(this.winWidth, this.winHeight);
        this.renderer.toneMapping = THREE.LinearToneMapping;
        this.renderer.toneMappingExposure = 1;
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.VSMShadowMap;
        this.renderer.localClippingEnabled = true;
      }
      
      createSim(){
        const fragmentShader = gameWrapper.querySelector('.simulationFragmentShader').textContent;
        const vertexShader = gameWrapper.querySelector('.simulationVertexShader').textContent;
        this.floorSimMat = new THREE.ShaderMaterial({
          uniforms: {
            inputTexture: {type: "t", value: null}, time: { value: 0.0 },
            blade1PosOld: {value: new THREE.Vector2(.5,.5)}, blade1PosNew: {value: new THREE.Vector2(.5,.5)},
            strength: {value: 0.0},
          },
          vertexShader, fragmentShader,
        });
        this.bufferSim = new BufferSim(this.renderer, 1024, 1024, this.floorSimMat)
      }
      
      createMaterials(){
        this.primMat = new THREE.MeshToonMaterial({ color: 0x7beeff });
        this.secMat = new THREE.MeshToonMaterial({ color: this.bgrColor });
        this.bonusMat = new THREE.MeshToonMaterial({ color: 0xff3434 });
        
        const fragmentShader = gameWrapper.querySelector('.outlineFragmentShader').textContent;
        const vertexShader = gameWrapper.querySelector('.outlineVertexShader').textContent;
        this.outlineMat = new THREE.ShaderMaterial({
          uniforms : { color: { value: new THREE.Color(0x000000) }, size: {type:"f", value:.02}, },
          vertexShader, fragmentShader, side:THREE.BackSide,
        });
      }
      
      addOutline(origin){
        let outline = origin.clone();
        outline.children = [];
        outline.position.set(0, 0, 0);
        outline.rotation.set(0,0,0);
        outline.scale.set(1,1,1);
        outline.material = this.outlineMat;
        origin.add(outline);
        return outline;
      }

      createListeners() {
        new ResizeObserver(() => this.onWindowResize()).observe(gameWrapper);
        gameWrapper.addEventListener("mousemove", this.onMouseMove.bind(this), false);
        gameWrapper.addEventListener("touchmove", this.onTouchMove.bind(this), false);
        gameWrapper.addEventListener("mousedown", this.onMouseDown.bind(this), false);
      }

      draw() {
        this.updateGame();
        this.renderer.render(this.scene, this.camera);
        requestAnimationFrame(this.draw.bind(this));
      }

      updateGame() {
        this.dt = Math.min(this.clock.getDelta(), 0.3);
        this.time += this.dt;

        if (this.rabbit && this.line) {
          let constrainUVPosX = this.constrain(this.targetHeroUVPos.x - 0.5, -0.3, 0.3);
          let constrainUVPosY = this.constrain(this.targetHeroUVPos.y - 0.5, -0.3, 0.3);
          this.targetHeroAbsMousePos.x = constrainUVPosX * this.floorSize;
          this.targetHeroAbsMousePos.y = -constrainUVPosY * this.floorSize;

          let dx = this.targetHeroAbsMousePos.x - this.rabbit.position.x;
          let dy = this.targetHeroAbsMousePos.y - this.rabbit.position.z;
          let angle = Math.atan2(dy, dx);
          this.heroDistance = Math.sqrt(dx * dx + dy * dy);
          
          this.heroSpeed.x += dx * this.dt * 0.5;
          this.heroSpeed.y += dy * this.dt * 0.5;
          this.heroSpeed.x *= Math.pow(this.dt, 0.005);
          this.heroSpeed.y *= Math.pow(this.dt, 0.005);

          this.rabbit.position.x += this.heroSpeed.x;
          this.rabbit.position.z += this.heroSpeed.y;
          let targetRot = -angle + Math.PI / 2;

          if (this.heroDistance > 0.3) this.rabbit.rotation.y += this.getShortestAngle(targetRot - this.rabbit.rotation.y) * 3 * this.dt;
          this.heroAngularSpeed = this.getShortestAngle( this.rabbit.rotation.y - this.heroOldRot);
          this.heroOldRot = this.rabbit.rotation.y;
          if (!this.isJumping) this.earLeft.rotation.x = this.earRight.rotation.x = -this.heroSpeed.length() * 2;
            
          let p = this.line.geometry.attributes.position.array;
          p[0] = this.targetHeroAbsMousePos.x; p[2] = this.targetHeroAbsMousePos.y;
          p[3] = this.rabbit.position.x; p[4] = this.rabbit.position.y; p[5] = this.rabbit.position.z;
          this.line.geometry.attributes.position.needsUpdate = true;
          this.line.computeLineDistances();
          
          this.heroNewUVPos = new THREE.Vector2(0.5 + this.rabbit.position.x / this.floorSize, 0.5 - this.rabbit.position.z / this.floorSize);
          this.floorSimMat.time += this.dt;
          this.floorSimMat.uniforms.blade1PosNew.value = this.heroNewUVPos;
          this.floorSimMat.uniforms.blade1PosOld.value = this.heroOldUVPos;
          this.floorSimMat.uniforms.strength.value = this.isJumping ? 0 : 1 / (1 + this.heroSpeed.length() * 10);
          this.bufferSim.render();
          this.renderer.setRenderTarget(null);
          this.floor.material.uniforms.tScratches.value = this.bufferSim.output.texture;
          this.heroOldUVPos = this.heroNewUVPos.clone();
          this.carrot.rotation.y += this.dt;
          this.testCollision();
        }
      }

      onWindowResize() {
        this.winWidth = gameWrapper.clientWidth;
        this.winHeight = gameWrapper.clientHeight;
        this.camera.aspect = this.winWidth / this.winHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.winWidth, this.winHeight);
      }

      updateMouse(x,y){
        this.mouse.x = x; this.mouse.y = y;
        if (this.floor) this.raycast(); 
      }
      
      onMouseMove(event) { this.updateMouse(event.clientX / this.winWidth * 2 - 1, -(event.clientY / this.winHeight * 2 - 1)); }
      onTouchMove(event) { if (event.touches.length == 1) { event.preventDefault(); this.updateMouse(event.touches[0].pageX / this.winWidth * 2 - 1, -(event.touches[0].pageY / this.winHeight * 2 - 1)); } }
      onMouseDown(){ if (this.rabbit && !this.isJumping) this.jump(); }
      
      jump() {
        this.isJumping = true;
        let turns = Math.floor(this.heroSpeed.length() * 5) + 1;
        let jumpDuration = .5 + turns * .2;
        let targetRot = (this.heroAngularSpeed > 0) ? Math.PI*2*turns : -Math.PI*2*turns;
        
        gsap.to(this.rabbitBody.rotation, { duration: jumpDuration, ease: "linear.none", y: targetRot, onComplete: () => { this.rabbitBody.rotation.y = 0; }});
        gsap.to([this.earLeft.rotation, this.earRight.rotation], { duration: jumpDuration*.8, ease: "power4.out", x: Math.PI/4 });
        gsap.to([this.earLeft.rotation, this.earRight.rotation], { duration: jumpDuration*.2, delay: jumpDuration*.8, ease: "power4.in", x: 0 });
        gsap.to(this.jumpParams, {
          duration: jumpDuration * .5, ease : "power2.out", jumpProgress:.5, 
          onUpdate: () => { this.rabbit.position.y = Math.pow(Math.sin( this.jumpParams.jumpProgress * Math.PI), 4) * turns; }
        });
        gsap.to(this.jumpParams, {
          duration: jumpDuration * .5, ease : "power2.in", delay : jumpDuration * .5, jumpProgress:1, 
          onUpdate: () => { this.rabbit.position.y = Math.pow(Math.sin( this.jumpParams.jumpProgress * Math.PI), 1) * turns; },
          onComplete: () => { this.rabbit.position.y = 0; this.jumpParams.jumpProgress = 0; this.isJumping = false; }
        });      
      }
      
      raycast() {
        this.raycaster.setFromCamera( this.mouse, this.camera );
        var intersects = this.raycaster.intersectObjects( [this.floor] );
        if (intersects.length > 0) { this.targetHeroUVPos.x = intersects[0].uv.x; this.targetHeroUVPos.y = intersects[0].uv.y; }
      }

      getShortestAngle(v) { let a=v%(Math.PI*2); if(a<-Math.PI)a+=Math.PI*2; else if(a>Math.PI)a-=Math.PI*2; return a; }
      constrain(v,vMin,vMax){ return Math.min(vMax,Math.max(vMin,v)); }
      
      testCollision(){
        if (this.isExploding) return;
        let distVec = this.rabbit.position.clone().sub(this.carrot.position);
        if (distVec.length() <= 1) { this.carrot.visible = false; this.explode(this.carrot.position); }
      }
      
      explode(pos){
        this.isExploding = true;
        const animateParticles = (particles, onCompleteCallback) => {
            particles.forEach((m, i) => {
                m.position.copy(pos);
                m.scale.set(2,2,2);
                gsap.to(m.position, {
                    x: pos.x + (-.5 + Math.random()) * 1.5,
                    y: pos.y + (.5 + Math.random()) * 1.5,
                    z: pos.z + (-.5 + Math.random()) * 1.5,
                    duration : 1, ease: "power4.out",
                });
                gsap.to(m.scale, {
                    x:0, y:0, z:0, duration : 1, ease: "power4.out",
                    onComplete: i === 0 ? onCompleteCallback : null, // only call once
                });
            });
        };
        const onExplosionComplete = () => {
            this.spawnCarrot();
            this.isExploding = false;
        };
        animateParticles(this.particles1, onExplosionComplete);
        animateParticles(this.particles2, null); // no callback for the second set
      }
      
      spawnCarrot(){
        let px = (Math.random() - .5) * .3; let py = (Math.random() - .5) * .3;
        this.carrot.position.set(px * this.floorSize, -1, py * this.floorSize);
        this.carrot.scale.set(0,0,0); this.carrot.visible = true;
        gsap.to(this.carrot.scale, { duration:1.5, ease: "elastic.out", x:1, y:1, z:1 });
        gsap.to(this.carrot.position, { duration:1.5, ease: "elastic.out", y: .2 + Math.random() * 1 });
      }
      
      modifyFloorShader(){
        let renderTarget = this.floor.getRenderTarget();
        const textureMatrix = this.floor.material.uniforms.textureMatrix;
        const fragmentShader = gameWrapper.querySelector('.reflectorFragmentShader').textContent;
        const vertexShader = gameWrapper.querySelector('.reflectorVertexShader').textContent;
        const uniforms = THREE.UniformsUtils.merge([
          THREE.UniformsLib['common'], THREE.UniformsLib['shadowmap'], THREE.UniformsLib['lights'],
          this.floor.material.uniforms, { tScratches : { value: this.bufferSim.output.texture } }
        ]);
        this.floor.material.lights = true;
        this.floor.material.uniforms = uniforms;
        this.floor.material.uniforms.tDiffuse.value = renderTarget.texture;
        this.floor.material.uniforms.textureMatrix.value = textureMatrix.value;
        this.floor.material.vertexShader = vertexShader;
        this.floor.material.fragmentShader = fragmentShader;
      }
    }
    
    // 启动 App
    new App();
  }
</script>
<!-- END: 弹性兔子游戏嵌入式代码 --></article><!-- lincense--><div class="post-paginator"><a class="nextSlogan" href="/2025/07/25/crossy%20road%20game/" title="3D版天天过马路小游戏"><span>NextPost ></span><br><span class="nextTitle">3D版天天过马路小游戏</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a target="_blank" rel="noopener" href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>